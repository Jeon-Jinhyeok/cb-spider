<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>S3 Manager</title>
<style>
    body { font-family: Arial, sans-serif; font-size: 12px; }
    .fixed-header { position: fixed; top: 0; width: 97%; background: #fff; z-index: 1000; display: flex; justify-content: space-between; padding: 10px 20px; align-items: center; box-shadow: 0 4px 6px -6px #222; }
    .header-container { display: flex; align-items: flex-end; }
    .header-container img { margin-right: 10px; height: 28px; }
    .header-container h1 { font-size: 16px; margin: 0; }
    .searchContainer { position: relative; display: flex; align-items: center; padding-left: 0.5cm; }
    #searchInput { width: 190px; font-family: Arial, sans-serif; padding-right: 2.5cm; }
    #clearSearch { position: absolute; right: 0.1cm; top: 50%; transform: translateY(-50%); border: none; background: transparent; cursor: pointer; }
    .fixed-action-buttons { display: flex; align-items: center; }
    .fixed-action-buttons button { margin-left: 10px; }
    .header-with-progress { display: flex; align-items: center; margin-bottom: 0px; }
    .progress-bar-container { width: 600px; margin-left: 10px; margin-bottom: 10px; height: 22px; background: #f0f5ff; border-radius: 4px; overflow: hidden; display: none; position: relative; z-index: 2000; }
    .progress-bar { width: 0; height: 100%; background: #cce6ff; border-radius: 4px; transition: width 2s ease; }
    #timeDisplay { position: absolute; top: 50%; right: 10px; transform: translateY(-50%); font-size: 14px; color: #333; z-index: 30; }
    .add-button { font-size: 14px; font-weight: bold; margin-left: 1px; margin-right: 5px; margin-bottom: 10px; }
    .content { margin-top: 70px; }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; margin-bottom: 0; }
    th, td { border: 1px solid #aaa; padding: 6px; position: relative; }
    th { background: #f2f2f2; font-size: 14px; text-align: center; }
    td { text-align: left; }
    .column-num { width: 5%; text-align: center; }
    .check-column { width: 5%; text-align: center; }
    .bucket-name-cell, .object-key-cell { font-weight: bold; }
    .bucket-name-cell.selected { color: blue; }
    .center-align { text-align: center; }
    .highlight { background: #fffab6; }
    .overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 1000; }
    .overlay-content { background: #fff; padding: 20px; border-radius: 5px; text-align: left; font-size: 12px; min-width: 300px; }
    .close-btn { position: absolute; top: 5px; right: 10px; background: none; border: none; font-size: 16px; cursor: pointer; }
    .object-detail-table th, .object-detail-table td { border: 1px solid #ddd; }
    .object-detail-table th { width: 110px; }
    .progress-bar { transition: width 1.5s ease; }
    #object-panel { margin-top: 20px; margin-left: 40px; }
    .object-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0px; }
    .object-panel-header h2 { margin: 0; }
    .object-panel-actions { display: flex; align-items: center; }
    
    /* Object Versions Table Styling */
    .object-versions-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    .object-versions-table th { border: 1px solid #ddd; padding: 8px; text-align: center; background: #f2f2f2; }
    .object-versions-table td { border: 1px solid #ddd; padding: 8px; }
    .object-versions-table td:first-child { text-align: left; } /* Object Key column - left aligned */
    .object-versions-table td:not(:first-child) { text-align: center; } /* All other columns - center aligned */
</style>
</head>
<body>
    <div class="fixed-header">
        <div class="header-container">
            <img src="/spider/adminweb/images/left-menu/s3.png" alt="S3 Icon">
            <h1>S3 Manager</h1>
            <div class="searchContainer">
                <input type="text" id="searchInput" onkeyup="searchKeyword()" placeholder="Search Bucket or Object...">
                <button id="clearSearch" onclick="clearSearchInput()">X</button>
            </div>
        </div>
        <div class="fixed-action-buttons">
            <input type="checkbox" onclick="toggleSelectAll(this, 'bucket')">
            <button onclick="deleteSelectedBuckets()">Delete</button>
        </div>
    </div>

    <div class="content">
        <div class="header-with-progress">
            <button onclick="showBucketCreateOverlay()" class="add-button">+ Bucket</button>
            <div class="progress-bar-container" id="progressBarContainer">
                <div class="progress-bar" id="progressBar"></div>
                <span id="timeDisplay"></span>
            </div>
        </div>

        <table id="bucket-table">
            <thead>
                <tr>
                    <th class="column-num">#</th>
                    <th class="center-align bucket-name-cell">Bucket Name</th>
                    <th class="center-align">Created</th>
                    <th class="center-align">Region</th>
                    <th class="center-align">Actions</th>
                    <th class="check-column"><input type="checkbox" onclick="toggleSelectAll(this, 'bucket')"></th>
                </tr>
            </thead>
            <tbody id="bucket-list-body">
                {{range $i, $b := .Buckets}}
                <tr>
                    <td class="column-num">{{$i | inc}}</td>
                    <td class="bucket-name-cell" id="bucket-{{$b.Name}}"><span style="cursor:pointer;" onclick="showObjectPanel('{{$b.Name}}')">{{$b.Name}}</span></td>
                    <td class="center-align">{{$b.CreationDate}}</td>
                    <td class="center-align">{{$b.BucketRegion}}</td>
                    <td class="center-align">
                        <button onclick="deleteBucket('{{$b.Name}}')">Delete</button>
                        <button onclick="showBucketSettings('{{$b.Name}}')">Settings</button>
                    </td>
                    <td class="check-column"><input type="checkbox" name="bucket-checkbox" value="{{$b.Name}}"></td>
                </tr>
                {{end}}
            </tbody>
        </table>

        <div id="object-panel" style="display:none;">
            <div class="header-with-progress">
                <button onclick="showObjectUploadOverlay()" class="add-button">+ Object</button>
                <button onclick="showObjectVersions()" class="add-button" style="margin-left: 10px;">Versions</button>
                <div style="flex: 1;"></div>
                <div class="object-panel-actions">
                    <input type="checkbox" onclick="toggleSelectAll(this, 'object')">
                    <button onclick="deleteSelectedObjects()" style="margin-left: 10px;">Delete</button>
                </div>
            </div>
            <table id="object-table">
                <thead>
                    <tr>
                        <th class="column-num">#</th>
                        <th class="object-key-cell">Object Key</th>
                        <th class="center-align">Size</th>
                        <th class="center-align">Last Modified</th>
                        <th class="center-align">Actions</th>
                        <th class="check-column"><input type="checkbox" onclick="toggleSelectAll(this, 'object')"></th>
                    </tr>
                </thead>
                <tbody id="object-list-body">
                </tbody>
            </table>
        </div>
    </div>

    <div id="bucket-create-overlay" class="overlay">
        <div class="overlay-content" style="position:relative;">
            <button class="close-btn" onclick="hideBucketCreateOverlay()">x</button>
            <h2>Create New Bucket</h2>
            <form id="bucket-create-form" onsubmit="event.preventDefault(); createBucket();">
                <div>
                    <label>Bucket Name:</label>
                    <input type="text" id="new-bucket-name" required>
                </div>
                <div style="margin-top:20px; text-align:center;">
                    <button type="submit">Create</button>
                    <button type="button" onclick="hideBucketCreateOverlay()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div id="object-upload-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 400px;">
            <button class="close-btn" onclick="hideObjectUploadOverlay()">x</button>
            <h2>Upload Objects to <span id="upload-bucket-name"></span></h2>
            <form id="object-upload-form" onsubmit="event.preventDefault(); uploadFiles();">
                <div style="margin-bottom: 15px;">
                    <label>Select Files:</label>
                    <input type="file" id="file-input" multiple required style="margin-top: 5px;">
                </div>
                <div id="selected-files-list" style="margin-bottom: 15px; max-height: 200px; overflow-y: auto;">No files selected</div>
                <div id="upload-progress" style="display: none; margin-bottom: 15px;">
                    <div style="margin-bottom: 5px;">Uploading: <span id="current-file"></span></div>
                    <div style="background: #f0f0f0; height: 20px; border-radius: 4px; overflow: hidden;">
                        <div id="progress-bar-inner" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="margin-top: 5px; font-size: 11px;">Progress: <span id="progress-text">0%</span></div>
                </div>
                <div style="text-align:center;">
                    <button type="submit" id="upload-btn">Upload</button>
                    <button type="button" onclick="hideObjectUploadOverlay()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div id="object-detail-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 500px;">
            <button class="close-btn" onclick="hideObjectDetailOverlay()">x</button>
            <h2>Object Detail: <span id="object-detail-key"></span></h2>
            <table class="object-detail-table" style="width:100%;">
                <tbody id="object-detail-body">
                </tbody>
            </table>
        </div>
    </div>

    <div id="bucket-settings-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 600px;">
            <button class="close-btn" onclick="hideBucketSettingsOverlay()">x</button>
            <h2>Bucket Settings: <span id="settings-bucket-name"></span></h2>
            
            <div style="margin-bottom: 20px;">
                <h3>Versioning</h3>
                <div>
                    <label>Status: <span id="versioning-status">Loading...</span></label>
                    <button onclick="toggleVersioning()" id="versioning-btn" style="margin-left: 10px;">Toggle</button>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <h3>CORS Configuration</h3>
                <div>
                    <label>Status: <span id="cors-status">Loading...</span></label>
                    <button onclick="enableCORS()" style="margin-left: 10px;">Enable CORS</button>
                    <button onclick="deleteCORS()" style="margin-left: 10px;">Delete CORS</button>
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <h3>Access Control (ACL)</h3>
                <div>
                    <label>Current ACL: <span id="acl-status">Loading...</span></label>
                    <br><br>
                    <select id="acl-select">
                        <option value="private">Private</option>
                        <option value="public-read">Public Read</option>
                    </select>
                    <button onclick="setACL()" style="margin-left: 10px;">Set ACL</button>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button onclick="hideBucketSettingsOverlay()">Close</button>
            </div>
        </div>
    </div>

    <div id="presigned-url-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 500px;">
            <button class="close-btn" onclick="hidePresignedURLOverlay()">x</button>
            <h2>Share Object: <span id="presigned-object-key"></span></h2>
            
            <div style="margin-bottom: 15px;">
                <label>Expiration (hours):</label>
                <input type="number" id="expiration-hours" value="1" min="1" max="168" style="margin-left: 10px; width: 80px;">
            </div>

            <div style="margin-bottom: 15px;">
                <label>Method:</label>
                <select id="presigned-method" style="margin-left: 10px;">
                    <option value="GET">Download (GET)</option>
                    <option value="PUT">Upload (PUT)</option>
                </select>
            </div>

            <div style="margin-bottom: 15px;">
                <button onclick="generatePresignedURLAction()">Generate URL</button>
            </div>

            <div id="presigned-url-result" style="display: none;">
                <label>Presigned URL:</label>
                <textarea id="presigned-url-text" readonly style="width: 100%; height: 100px; margin-top: 5px;"></textarea>
                <button onclick="copyPresignedURL()" style="margin-top: 10px;">Copy URL</button>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button onclick="hidePresignedURLOverlay()">Close</button>
            </div>
        </div>
    </div>

    <div id="object-versions-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 900px; max-width: 90vw; max-height: 80vh; overflow-y: auto;">
            <button class="close-btn" onclick="hideObjectVersionsOverlay()">x</button>
            <h2>Object Versions in: <span id="versions-bucket-name"></span></h2>
            
            <div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px;">
                <strong>Note:</strong> Versioning-enabled buckets cannot be deleted until all object versions and delete markers are removed.
                <br>Use the "Delete" buttons below or "Empty Bucket" to clean up before deleting the bucket.
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-bottom: 10px;">
                <button onclick="deleteAllVersions(document.getElementById('versions-bucket-name').textContent)" 
                        style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; font-weight: bold; cursor: pointer;">
                    🗂️ Empty Bucket
                </button>
            </div>
            
            <table class="object-versions-table">
                <thead>
                    <tr>
                        <th>Object Key</th>
                        <th>Version ID</th>
                        <th>Size</th>
                        <th>Last Modified</th>
                        <th>Latest</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="object-versions-body">
                </tbody>
            </table>

            <div style="text-align: center; margin-top: 20px;">
                <button onclick="hideObjectVersionsOverlay()">Close</button>
            </div>
        </div>
    </div>

<script>
const connConfig = "{{.ConnectionConfig}}";

function showProgressBar() {
    const bar = document.getElementById('progressBar');
    const cont = document.getElementById('progressBarContainer');
    bar.style.width = '0%'; cont.style.display = 'block';
    setTimeout(() => { bar.style.width = '100%'; }, 50);
}
function hideProgressBar() {
    setTimeout(() => {
        document.getElementById('progressBarContainer').style.display = 'none';
        document.getElementById('timeDisplay').textContent = '';
    }, 500);
}

function createBucket() {
    const name = document.getElementById('new-bucket-name').value.trim();
    if (!name) return alert('Bucket name required!');
    showProgressBar();
    
    fetch(`/spider/${name}?ConnectionName=${connConfig}`, {
        method: 'PUT'
    })
    .then(response => {
        if (response.ok) {
            hideBucketCreateOverlay(); 
            location.reload();
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

function deleteBucket(name) {
    if (!confirm(`Delete bucket "${name}"?\n\nWarning: The bucket must be empty before it can be deleted. If the bucket contains objects, the deletion will fail.`)) return;
    showProgressBar();
    
    fetch(`/spider/${name}?ConnectionName=${connConfig}`, { 
        method: 'DELETE',
        headers: {
            'X-Connection-Name': connConfig
        }
    })
    .then(response => {
        if (response.ok) {
            location.reload();
        } else {
            return response.text().then(errorText => {
                if (errorText.includes('<?xml') || errorText.includes('<Error>')) {
                    try {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(errorText, 'text/xml');
                        const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                        const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || 'Unknown error';
                        
                        if (errorCode === 'BucketNotEmpty') {
                            throw new Error(`Cannot delete bucket "${name}": The bucket is not empty.\n\nPlease delete all objects in the bucket first, then try again.`);
                        } else if (errorCode === 'NoSuchBucket') {
                            throw new Error(`Bucket "${name}" does not exist.`);
                        } else if (errorCode === 'AccessDenied') {
                            throw new Error(`Access denied: You don't have permission to delete bucket "${name}".`);
                        } else {
                            throw new Error(`${errorCode}: ${errorMessage}`);
                        }
                    } catch (parseError) {
                        if (parseError.message.includes('Cannot delete bucket')) {
                            throw parseError;
                        }
                        throw new Error(`HTTP ${response.status}: ${errorText}`);
                    }
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
                }
            });
        }
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

async function deleteObjectVersion(bucketName, objectKey, versionId) {
    if (versionId === null || versionId === undefined) {
        alert('Cannot delete: Version ID is null or undefined');
        return;
    }
    
    const cleanVersionId = String(versionId).trim();
    
    if (cleanVersionId === 'null' || cleanVersionId === 'undefined' || cleanVersionId === '') {
        if (objectKey.includes('DELETE MARKER') || confirm(`Version ID appears to be invalid ('${cleanVersionId}'). This might be a DELETE MARKER. Try to delete anyway?`)) {
            // Continue with deletion
        } else {
            alert('Cannot delete: Invalid version ID');
            return;
        }
    }
    
    if (!confirm(`Delete version ${cleanVersionId.substring(0, 20)}... of object "${objectKey}"?`)) return;
    
    showProgressBar();
    
    try {
        const url = `/spider/${bucketName}/${encodeURIComponent(objectKey)}?versionId=${encodeURIComponent(cleanVersionId)}&ConnectionName=${connConfig}`;
        
        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'X-Connection-Name': connConfig
            }
        });
        
        hideProgressBar();
        
        if (response.ok) {
            loadObjectVersionsWithActions(bucketName);
        } else {
            const errorText = await response.text();
            
            if (errorText.includes('<?xml') || errorText.includes('<e>')) {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(errorText, 'text/xml');
                    const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                    const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || 'Unknown error';
                    throw new Error(`${errorCode}: ${errorMessage}`);
                } catch (parseError) {
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        }
    } catch (error) {
        hideProgressBar();
        alert('Error deleting version: ' + error.message);
    }
}

async function deleteAllVersions(bucketName) {
    if (!confirm(`Delete ALL object versions and delete markers in bucket "${bucketName}"?\n\nThis action cannot be undone!`)) return;
    
    showProgressBar();
    
    try {
        const response = await fetch(`/spider/${bucketName}?versions&ConnectionName=${connConfig}`);
        const xmlData = await response.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
        
        const versions = xmlDoc.getElementsByTagName('Version');
        const deleteMarkers = xmlDoc.getElementsByTagName('DeleteMarker');
        
        if (versions.length === 0 && deleteMarkers.length === 0) {
            alert('No versions or delete markers to delete');
            hideProgressBar();
            return;
        }
        
        let successCount = 0;
        let failureCount = 0;
        const errors = [];
        
        for (let i = 0; i < versions.length; i++) {
            const version = versions[i];
            const key = version.getElementsByTagName('Key')[0]?.textContent;
            const versionId = version.getElementsByTagName('VersionId')[0]?.textContent;
            
            if (key && versionId) {
                try {
                    const url = `/spider/${bucketName}/${encodeURIComponent(key)}?versionId=${encodeURIComponent(versionId)}&ConnectionName=${connConfig}`;
                    const deleteResponse = await fetch(url, {
                        method: 'DELETE',
                        headers: {
                            'X-Connection-Name': connConfig
                        }
                    });
                    
                    if (deleteResponse.ok) {
                        successCount++;
                    } else {
                        failureCount++;
                        const errorText = await deleteResponse.text();
                        errors.push(`${key} (${versionId}): ${deleteResponse.status} ${deleteResponse.statusText}`);
                    }
                } catch (error) {
                    failureCount++;
                    errors.push(`${key} (${versionId}): ${error.message}`);
                }
            }
        }
        
        for (let i = 0; i < deleteMarkers.length; i++) {
            const marker = deleteMarkers[i];
            const key = marker.getElementsByTagName('Key')[0]?.textContent;
            const versionId = marker.getElementsByTagName('VersionId')[0]?.textContent;
            
            if (key && versionId) {
                try {
                    const url = `/spider/${bucketName}/${encodeURIComponent(key)}?versionId=${encodeURIComponent(versionId)}&ConnectionName=${connConfig}`;
                    const deleteResponse = await fetch(url, {
                        method: 'DELETE',
                        headers: {
                            'X-Connection-Name': connConfig
                        }
                    });
                    
                    if (deleteResponse.ok) {
                        successCount++;
                    } else {
                        failureCount++;
                        const errorText = await deleteResponse.text();
                        errors.push(`${key} (DELETE MARKER - ${versionId}): ${deleteResponse.status} ${deleteResponse.statusText}`);
                    }
                } catch (error) {
                    failureCount++;
                    errors.push(`${key} (DELETE MARKER - ${versionId}): ${error.message}`);
                }
            }
        }
        
        hideProgressBar();
        
        if (failureCount > 0) {
            let message = `Deletion completed with errors:\n\n`;
            message += `Successfully deleted: ${successCount} items\n`;
            message += `Failed to delete: ${failureCount} items\n\n`;
            message += `Errors:\n`;
            errors.slice(0, 10).forEach(error => {
                message += `- ${error}\n`;
            });
            
            if (errors.length > 10) {
                message += `... and ${errors.length - 10} more errors\n`;
            }
            
            alert(message);
        }
        
        loadObjectVersionsWithActions(bucketName);
        
    } catch (error) {
        hideProgressBar();
        alert('Error deleting all versions: ' + error.message);
    }
}

function deleteSelectedBuckets() {
    const checked = document.querySelectorAll('input[name="bucket-checkbox"]:checked');
    if (!checked.length) return alert("Select bucket(s) to delete!");
    
    const bucketNames = Array.from(checked).map(chk => chk.value).join(', ');
    if (!confirm(`Delete selected bucket(s): ${bucketNames}?\n\nWarning: All buckets must be empty before they can be deleted.`)) return;
    
    showProgressBar();
    
    const deletePromises = Array.from(checked).map(chk => {
        const bucketName = chk.value;
        return fetch(`/spider/${bucketName}?ConnectionName=${connConfig}`, { 
            method: 'DELETE',
            headers: {
                'X-Connection-Name': connConfig
            }
        }).then(response => {
            if (!response.ok) {
                return response.text().then(errorText => {
                    if (errorText.includes('BucketNotEmpty')) {
                        return { bucket: bucketName, error: 'Bucket is not empty' };
                    } else if (errorText.includes('NoSuchBucket')) {
                        return { bucket: bucketName, error: 'Bucket does not exist' };
                    } else if (errorText.includes('AccessDenied')) {
                        return { bucket: bucketName, error: 'Access denied' };
                    } else {
                        return { bucket: bucketName, error: `HTTP ${response.status}` };
                    }
                });
            }
            return { bucket: bucketName, success: true };
        }).catch(error => {
            return { bucket: bucketName, error: 'Network error' };
        });
    });
    
    Promise.all(deletePromises).then(results => {
        hideProgressBar();
        
        const successes = results.filter(r => r.success);
        const failures = results.filter(r => r.error);
        
        if (failures.length > 0) {
            let message = `Deletion completed:\n\n`;
            if (successes.length > 0) {
                message += `Successfully deleted: ${successes.map(s => s.bucket).join(', ')}\n\n`;
            }
            message += `Failed to delete:\n`;
            failures.forEach(f => {
                message += `- ${f.bucket}: ${f.error}\n`;
            });
            alert(message);
        }
        
        location.reload();
    }).catch(e => { 
        alert('Error during bulk deletion: ' + e.message); 
        hideProgressBar(); 
    });
}

function showBucketCreateOverlay() { document.getElementById('bucket-create-overlay').style.display = 'flex'; }
function hideBucketCreateOverlay() { document.getElementById('bucket-create-overlay').style.display = 'none'; }

let currentBucket = null;
let currentPrefix = "";

function showObjectPanel(bucket, prefix = "") {
    currentBucket = bucket;
    currentPrefix = prefix;
    
    document.querySelectorAll('.bucket-name-cell').forEach(el => el.classList.remove('selected'));
    document.getElementById(`bucket-${bucket}`).classList.add('selected');
    document.getElementById('object-panel').style.display = 'block';
    
    updateObjectPanelHeader(bucket, prefix);
    
    fetchObjects(bucket, prefix);
}

function updateObjectPanelHeader(bucket, prefix) {
    const header = document.querySelector('.object-panel-header h2');
    if (!header) {
        const panelHeader = document.querySelector('.object-panel-header');
        if (panelHeader) {
            const h2 = document.createElement('h2');
            h2.style.margin = '0';
            panelHeader.insertBefore(h2, panelHeader.firstChild);
        }
    }
    
    const headerElement = document.querySelector('.object-panel-header h2');
    if (headerElement) {
        if (prefix && prefix !== "") {
            headerElement.innerHTML = `
                Objects in: <strong>${bucket}</strong>/${prefix}
                <button onclick="showObjectPanel('${bucket}', '')" style="margin-left: 10px; font-size: 12px;">📁 Root</button>
            `;
        } else {
            headerElement.innerHTML = `Objects in: <strong>${bucket}</strong>`;
        }
    }
}

function fetchObjects(bucket, prefix = "") {
    let url = `/spider/${bucket}?delimiter=/&ConnectionName=${connConfig}`;
    if (prefix && prefix !== "") {
        url += `&prefix=${encodeURIComponent(prefix)}`;
    }
    
    fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.text();
        })
        .then(xmlData => {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
            
            const parseError = xmlDoc.getElementsByTagName('parsererror')[0];
            if (parseError) {
                throw new Error('Failed to parse XML response');
            }
            
            const errorElement = xmlDoc.getElementsByTagName('e>')[0];
            if (errorElement) {
                const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || 'Unknown error';
                throw new Error(`${errorCode}: ${errorMessage}`);
            }
            
            const listBucketResult = xmlDoc.getElementsByTagName('ListBucketResult')[0];
            if (!listBucketResult) {
                throw new Error('Invalid XML response format');
            }
            
            const contents = xmlDoc.getElementsByTagName('Contents');
            const commonPrefixes = xmlDoc.getElementsByTagName('CommonPrefixes');
            
            const body = document.getElementById('object-list-body');
            body.innerHTML = '';
            
            let itemCount = 0;
            
            for (let i = 0; i < commonPrefixes.length; i++) {
                const prefixElement = commonPrefixes[i].getElementsByTagName('Prefix')[0];
                if (prefixElement) {
                    const folderPrefix = prefixElement.textContent;
                    
                    let folderName = folderPrefix;
                    if (prefix && folderPrefix.startsWith(prefix)) {
                        folderName = folderPrefix.substring(prefix.length);
                    }
                    if (folderName.endsWith('/')) {
                        folderName = folderName.slice(0, -1);
                    }
                    
                    itemCount++;
                    body.innerHTML += `
                        <tr style="background-color: #f8f9fa;">
                            <td class="column-num">${itemCount}</td>
                            <td class="object-key-cell">
                                <span style="cursor:pointer; font-weight: bold; color: #0066cc;" onclick="showObjectPanel('${bucket}', '${folderPrefix}')">
                                    📁 ${folderName}/
                                </span>
                            </td>
                            <td class="center-align">-</td>
                            <td class="center-align">-</td>
                            <td class="center-align">
                                <button onclick="showObjectPanel('${bucket}', '${folderPrefix}')">Open</button>
                                <button onclick="deleteFolder('${bucket}', '${folderPrefix}')">Delete</button>
                            </td>
                            <td class="check-column"><input type="checkbox" name="object-checkbox" value="${folderPrefix}"></td>
                        </tr>
                    `;
                }
            }
            
            for (let i = 0; i < contents.length; i++) {
                const content = contents[i];
                const key = content.getElementsByTagName('Key')[0]?.textContent || '';
                const size = parseInt(content.getElementsByTagName('Size')[0]?.textContent || '0');
                const lastModified = content.getElementsByTagName('LastModified')[0]?.textContent || '';
                
                let displayName = key;
                if (prefix && key.startsWith(prefix)) {
                    displayName = key.substring(prefix.length);
                }
                
                itemCount++;
                body.innerHTML += `
                    <tr>
                        <td class="column-num">${itemCount}</td>
                        <td class="object-key-cell">
                            <span style="cursor:pointer;" onclick="showObjectDetail('${bucket}','${key.replace(/'/g, "\\'")}')">${displayName}</span>
                        </td>
                        <td class="center-align">${formatBytes(size)}</td>
                        <td class="center-align">${formatTime(lastModified)}</td>
                        <td class="center-align">
                            <button onclick="downloadObject('${bucket}','${key.replace(/'/g, "\\'")}')">Download</button>
                            <button onclick="deleteObject('${bucket}','${key.replace(/'/g, "\\'")}')">Delete</button>
                            <button onclick="generatePresignedURL('${bucket}','${key.replace(/'/g, "\\'")}')">Share</button>
                        </td>
                        <td class="check-column"><input type="checkbox" name="object-checkbox" value="${key}"></td>
                    </tr>
                `;
            }
            
            if (itemCount === 0) {
                body.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">No objects found</td></tr>';
            }
        })
        .catch(e => {
            const body = document.getElementById('object-list-body');
            body.innerHTML = `<tr><td colspan="6" style="text-align: center; padding: 20px; color: red;">Error loading objects: ${e.message}</td></tr>`;
            alert('Error fetching objects: ' + e.message);
        });
}

function hideObjectPanel() {
    document.getElementById('object-panel').style.display = 'none';
    document.getElementById('object-list-body').innerHTML = '';
    document.querySelectorAll('.bucket-name-cell').forEach(el => el.classList.remove('selected'));
    currentBucket = null;
}

function fetchObjects(bucket) {
    console.log(`Fetching objects for bucket: ${bucket}`);
    
    const url = `/spider/${bucket}?ConnectionName=${connConfig}`;
    console.log(`Request URL: ${url}`);
    
    fetch(url)
        .then(response => {
            console.log(`Response status: ${response.status} ${response.statusText}`);
            console.log(`Response headers:`, response.headers);
            console.log(`Response Content-Type: ${response.headers.get('Content-Type')}`);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return response.text();
        })
        .then(xmlData => {
            console.log(`Response XML length: ${xmlData.length}`);
            console.log(`Response XML preview: ${xmlData.substring(0, 500)}`);
            
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
            
            const parseError = xmlDoc.getElementsByTagName('parsererror')[0];
            if (parseError) {
                console.error('XML parsing error:', parseError.textContent);
                throw new Error('Failed to parse XML response');
            }
            
            const errorElement = xmlDoc.getElementsByTagName('e>')[0];
            if (errorElement) {
                const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || 'Unknown error';
                throw new Error(`${errorCode}: ${errorMessage}`);
            }
            
            const listBucketResult = xmlDoc.getElementsByTagName('ListBucketResult')[0];
            if (!listBucketResult) {
                console.error('No ListBucketResult found in XML');
                console.error('Available root elements:', xmlDoc.documentElement?.tagName);
                throw new Error('Invalid XML response format');
            }
            
            const contents = xmlDoc.getElementsByTagName('Contents');
            const commonPrefixes = xmlDoc.getElementsByTagName('CommonPrefixes');
            
            console.log(`Found ${contents.length} objects and ${commonPrefixes.length} common prefixes`);
            
            const body = document.getElementById('object-list-body');
            body.innerHTML = '';
            
            let itemCount = 0;
            
            for (let i = 0; i < contents.length; i++) {
                const content = contents[i];
                const key = content.getElementsByTagName('Key')[0]?.textContent || '';
                const size = parseInt(content.getElementsByTagName('Size')[0]?.textContent || '0');
                const lastModified = content.getElementsByTagName('LastModified')[0]?.textContent || '';
                const etag = content.getElementsByTagName('ETag')[0]?.textContent || '';
                const storageClass = content.getElementsByTagName('StorageClass')[0]?.textContent || 'STANDARD';
                
                console.log(`Object ${i+1}: ${key} (${size} bytes)`);
                
                itemCount++;
                body.innerHTML += `
                    <tr>
                        <td class="column-num">${itemCount}</td>
                        <td class="object-key-cell"><span style="cursor:pointer;" onclick="showObjectDetail('${bucket}','${key.replace(/'/g, "\\'")}')">${key}</span></td>
                        <td class="center-align">${formatBytes(size)}</td>
                        <td class="center-align">${formatTime(lastModified)}</td>
                        <td class="center-align">
                            <button onclick="downloadObject('${bucket}','${key.replace(/'/g, "\\'")}')">Download</button>
                            <button onclick="deleteObject('${bucket}','${key.replace(/'/g, "\\'")}')">Delete</button>
                            <button onclick="generatePresignedURL('${bucket}','${key.replace(/'/g, "\\'")}')">Share</button>
                        </td>
                        <td class="check-column"><input type="checkbox" name="object-checkbox" value="${key}"></td>
                    </tr>
                `;
            }
            
            for (let i = 0; i < commonPrefixes.length; i++) {
                const prefix = commonPrefixes[i].getElementsByTagName('Prefix')[0]?.textContent || '';
                if (prefix) {
                    console.log(`Folder ${i+1}: ${prefix}`);
                    
                    itemCount++;
                    const displayName = prefix.endsWith('/') ? prefix.slice(0, -1) : prefix;
                    const folderName = displayName.split('/').pop() || displayName;
                    
                    body.innerHTML += `
                        <tr style="background-color: #f8f9fa;">
                            <td class="column-num">${itemCount}</td>
                            <td class="object-key-cell">
                                <span style="cursor:pointer; font-weight: bold;" onclick="showFolderContents('${bucket}','${prefix}')">
                                    📁 ${folderName}/
                                </span>
                            </td>
                            <td class="center-align">-</td>
                            <td class="center-align">-</td>
                            <td class="center-align">
                                <button onclick="showFolderContents('${bucket}','${prefix}')">Open</button>
                                <button onclick="deleteFolder('${bucket}','${prefix}')">Delete</button>
                            </td>
                            <td class="check-column"><input type="checkbox" name="object-checkbox" value="${prefix}"></td>
                        </tr>
                    `;
                }
            }
            
            if (itemCount === 0) {
                body.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">No objects found</td></tr>';
                console.log('No objects or folders found in bucket');
            } else {
                console.log(`Total items displayed: ${itemCount}`);
            }
        })
        .catch(e => {
            console.error('Error fetching objects:', e);
            const body = document.getElementById('object-list-body');
            body.innerHTML = `<tr><td colspan="6" style="text-align: center; padding: 20px; color: red;">Error loading objects: ${e.message}</td></tr>`;
            alert('Error fetching objects: ' + e.message);
        });
}

function showFolderContents(bucket, prefix) {
    console.log(`Opening folder: ${prefix} in bucket: ${bucket}`);
    
    const url = `/spider/${bucket}?prefix=${encodeURIComponent(prefix)}&delimiter=/&ConnectionName=${connConfig}`;
    console.log(`Fetching folder contents from: ${url}`);
    
    fetch(url)
        .then(response => response.text())
        .then(xmlData => {
            console.log(`Folder contents XML: ${xmlData.substring(0, 500)}`);
            alert(`Folder contents for ${prefix}:\n\nSee console for details. \nImplement drill-down view as needed.`);
        })
        .catch(e => {
            console.error('Error fetching folder contents:', e);
            alert('Error fetching folder contents: ' + e.message);
        });
}

function deleteFolder(bucket, prefix) {
    if (!confirm(`Delete folder "${prefix}" and ALL its contents?\n\nThis action cannot be undone.`)) return;
    
    console.log(`Deleting folder: ${prefix} from bucket: ${bucket}`);
    showProgressBar();
    
    const url = `/spider/${bucket}?prefix=${encodeURIComponent(prefix)}&ConnectionName=${connConfig}`;
    
    fetch(url)
        .then(response => response.text())
        .then(xmlData => {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
            const contents = xmlDoc.getElementsByTagName('Contents');
            
            if (contents.length === 0) {
                alert('Folder appears to be empty or already deleted');
                hideProgressBar();
                fetchObjects(bucket, currentPrefix);
                return;
            }
            
            const objectsToDelete = [];
            for (let i = 0; i < contents.length; i++) {
                const key = contents[i].getElementsByTagName('Key')[0]?.textContent;
                if (key) {
                    objectsToDelete.push(key);
                }
            }
            
            console.log(`Found ${objectsToDelete.length} objects to delete in folder ${prefix}`);
            
            const deleteXml = `<?xml version="1.0" encoding="UTF-8"?>
<Delete>
    ${objectsToDelete.map(key => `<Object><Key>${key}</Key></Object>`).join('')}
</Delete>`;
            
            return fetch(`/spider/${bucket}?delete&ConnectionName=${connConfig}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/xml'
                },
                body: deleteXml
            });
        })
        .then(response => {
            hideProgressBar();
            if (response.ok) {
                alert(`Folder "${prefix}" deleted successfully`);
                fetchObjects(bucket, currentPrefix);
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        })
        .catch(e => {
            console.error('Error deleting folder:', e);
            hideProgressBar();
            alert('Error deleting folder: ' + e.message);
        });
}

function deleteObject(bucket, objectKey) {
    if (!confirm(`Delete object "${objectKey}"?`)) return;
    showProgressBar();
    
    fetch(`/spider/${bucket}/${encodeURIComponent(objectKey)}?ConnectionName=${connConfig}`, {
        method: 'DELETE'
    })
    .then(response => {
        if (response.ok) {
            fetchObjects(bucket); 
            hideProgressBar(); 
            uncheckAllCheckboxes('object');
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

function deleteSelectedObjects() {
    const checked = document.querySelectorAll('input[name="object-checkbox"]:checked');
    if (!checked.length) return alert("Select object(s) to delete!");
    if (!confirm("Delete selected object(s)?")) return;
    showProgressBar();
    
    const objectsXml = Array.from(checked).map(chk => 
        `<Object><Key>${chk.value}</Key></Object>`
    ).join('');
    
    const deleteXml = `<?xml version="1.0" encoding="UTF-8"?>
<Delete>
    ${objectsXml}
</Delete>`;
    
    fetch(`/spider/${currentBucket}?delete&ConnectionName=${connConfig}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/xml'
        },
        body: deleteXml
    })
    .then(response => {
        if (response.ok) {
            fetchObjects(currentBucket); 
            hideProgressBar(); 
            uncheckAllCheckboxes('object');
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

function uncheckAllCheckboxes(mode) {
    const checkboxes = document.getElementsByName(mode + '-checkbox');
    for (const c of checkboxes) {
        c.checked = false;
    }
    
    const selectAllCheckboxes = document.querySelectorAll(`#${mode}-table thead input[type="checkbox"]`);
    selectAllCheckboxes.forEach(cb => cb.checked = false);
    
    if (mode === 'bucket') {
        const fixedHeaderCheckbox = document.querySelector('.fixed-action-buttons input[type="checkbox"]');
        if (fixedHeaderCheckbox) fixedHeaderCheckbox.checked = false;
    }
    
    if (mode === 'object') {
        const objectPanelCheckbox = document.querySelector('.object-panel-actions input[type="checkbox"]');
        if (objectPanelCheckbox) objectPanelCheckbox.checked = false;
    }
}

function showObjectUploadOverlay() {
    if (!currentBucket) return;
    document.getElementById('upload-bucket-name').innerText = currentBucket;
    document.getElementById('object-upload-overlay').style.display = 'flex';
    document.getElementById('file-input').value = '';
    document.getElementById('selected-files-list').innerHTML = 'No files selected';
    document.getElementById('upload-progress').style.display = 'none';
    
    document.getElementById('file-input').addEventListener('change', function(e) {
        const files = e.target.files;
        const fileList = document.getElementById('selected-files-list');
        if (files.length === 0) {
            fileList.innerHTML = 'No files selected';
        } else {
            fileList.innerHTML = '<strong>Selected files:</strong><br>';
            for (let i = 0; i < files.length; i++) {
                fileList.innerHTML += `${i + 1}. ${files[i].name} (${formatBytes(files[i].size)})<br>`;
            }
        }
    });
}

function hideObjectUploadOverlay() { 
    document.getElementById('object-upload-overlay').style.display = 'none';
    document.getElementById('file-input').value = '';
    document.getElementById('selected-files-list').innerHTML = 'No files selected';
    document.getElementById('upload-progress').style.display = 'none';
}

async function uploadFiles() {
    const files = document.getElementById('file-input').files;
    if (!files.length) return alert('Please select files to upload!');
    
    const uploadBtn = document.getElementById('upload-btn');
    uploadBtn.disabled = true;
    document.getElementById('upload-progress').style.display = 'block';
    
    let successCount = 0;
    let failedFiles = [];
    
    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        document.getElementById('current-file').textContent = file.name;
        document.getElementById('progress-bar-inner').style.width = '0%';
        document.getElementById('progress-text').textContent = `0% (${i + 1}/${files.length})`;
        
        try {
            const response = await uploadWithProgress(`/spider/${currentBucket}/${encodeURIComponent(file.name)}?ConnectionName=${connConfig}`, file, (progress) => {
                document.getElementById('progress-bar-inner').style.width = progress + '%';
                document.getElementById('progress-text').textContent = `${Math.round(progress)}% (${i + 1}/${files.length})`;
            });
            
            if (!response.ok) {
                throw new Error(`Upload failed: ${response.statusText} (${response.status})`);
            }
            
            successCount++;
            
        } catch (error) {
            failedFiles.push({name: file.name, error: error.message});
        }
    }
    
    uploadBtn.disabled = false;
    
    if (failedFiles.length > 0) {
        let errorMsg = `Upload completed with errors:\n\nSuccessfully uploaded: ${successCount} file(s)\n\nFailed files:\n`;
        failedFiles.forEach(f => {
            errorMsg += `- ${f.name}: ${f.error}\n`;
        });
        alert(errorMsg);
    }
    
    hideObjectUploadOverlay();
    fetchObjects(currentBucket);
}

function uploadWithProgress(url, file, onProgress) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        
        xhr.upload.addEventListener('progress', (e) => {
            if (e.lengthComputable) {
                const percentComplete = (e.loaded / e.total) * 100;
                onProgress(percentComplete);
            }
        });
        
        xhr.addEventListener('load', () => {
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve({ ok: true, status: xhr.status, statusText: xhr.statusText });
            } else {
                resolve({ ok: false, status: xhr.status, statusText: xhr.statusText });
            }
        });
        
        xhr.addEventListener('error', () => {
            reject(new Error('Network error'));
        });
        
        xhr.addEventListener('timeout', () => reject(new Error('Request timeout')));
        
        xhr.open('PUT', url, true);
        xhr.timeout = 600000;
        xhr.send(file);
    });
}

function showObjectDetail(bucket, key) {
    showProgressBar();
    
    fetch(`/spider/${bucket}/${encodeURIComponent(key)}?ConnectionName=${connConfig}`, {
        method: 'HEAD'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const size = response.headers.get('Content-Length') || '0';
        const lastModified = response.headers.get('Last-Modified') || '';
        const etag = response.headers.get('ETag') || '';
        const contentType = response.headers.get('Content-Type') || '';
        
        document.getElementById('object-detail-key').innerText = key;
        const tbody = document.getElementById('object-detail-body');
        tbody.innerHTML = `
            <tr><th>Key</th><td>${key}</td></tr>
            <tr><th>Size</th><td>${formatBytes(parseInt(size))}</td></tr>
            <tr><th>Last Modified</th><td>${lastModified}</td></tr>
            <tr><th>ETag</th><td>${etag}</td></tr>
            <tr><th>ContentType</th><td>${contentType}</td></tr>
            <tr><th>Actions</th><td>
                <button onclick="downloadObject('${bucket}','${key}')">Download</button>
                <button onclick="generatePresignedURL('${bucket}','${key}')">Share</button>
            </td></tr>
        `;
        document.getElementById('object-detail-overlay').style.display = 'flex';
        hideProgressBar();
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

function hideObjectDetailOverlay() { 
    document.getElementById('object-detail-overlay').style.display = 'none'; 
}

function downloadObjectVersion(bucket, key, versionId) {
    if (versionId === null || versionId === undefined) {
        alert('Cannot download: Version ID is null or undefined');
        return;
    }
    
    const cleanVersionId = String(versionId).trim();
    
    let downloadUrl;
    if (cleanVersionId && cleanVersionId !== '' && cleanVersionId !== 'undefined') {
        downloadUrl = `/spider/${bucket}/${encodeURIComponent(key)}?versionId=${encodeURIComponent(cleanVersionId)}&ConnectionName=${encodeURIComponent(connConfig)}`;
    } else {
        downloadUrl = `/spider/${bucket}/${encodeURIComponent(key)}?ConnectionName=${encodeURIComponent(connConfig)}`;
    }
    
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = key.split('/').pop() || key;
    link.target = '_blank';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function downloadObject(bucket, key) {
    const url = `/spider/${bucket}/${encodeURIComponent(key)}?ConnectionName=${connConfig}`;
    window.open(url, '_blank');
}

function showBucketSettings(bucketName) {
    document.getElementById('settings-bucket-name').textContent = bucketName;
    document.getElementById('bucket-settings-overlay').style.display = 'flex';
    
    loadBucketSettings(bucketName);
}

function hideBucketSettingsOverlay() {
    document.getElementById('bucket-settings-overlay').style.display = 'none';
}

async function loadBucketSettings(bucketName) {
    // Helper function to make silent requests
    const silentFetch = async (url) => {
        try {
            const response = await fetch(url);
            return response;
        } catch (error) {
            // Silently handle network errors
            return { ok: false, status: 500 };
        }
    };

    try {
        // Load versioning status
        try {
            const versioningResponse = await silentFetch(`/spider/${bucketName}?versioning&ConnectionName=${connConfig}`);
            
            if (versioningResponse.ok) {
                const versioningXml = await versioningResponse.text();
                
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(versioningXml, 'text/xml');
                const status = xmlDoc.getElementsByTagName('Status')[0]?.textContent || 'Suspended';
                
                document.getElementById('versioning-status').textContent = status;
            } else {
                document.getElementById('versioning-status').textContent = 'Error loading status';
            }
        } catch (error) {
            document.getElementById('versioning-status').textContent = 'Error';
        }

        // Load CORS status - handle 500 errors silently
        try {
            const corsResponse = await silentFetch(`/spider/${bucketName}?cors&ConnectionName=${connConfig}`);
            if (corsResponse.ok) {
                document.getElementById('cors-status').textContent = 'Configured';
            } else {
                // Any non-200 response (404, 500, etc.) means CORS is not configured
                document.getElementById('cors-status').textContent = 'Not configured';
            }
        } catch (error) {
            document.getElementById('cors-status').textContent = 'Not configured';
        }

        // Load ACL status
        try {
            const aclResponse = await silentFetch(`/spider/${bucketName}?acl&ConnectionName=${connConfig}`);
            if (aclResponse.ok) {
                const aclXml = await aclResponse.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(aclXml, 'text/xml');
                const grants = xmlDoc.getElementsByTagName('Grant');
                let isPublic = false;
                for (let i = 0; i < grants.length; i++) {
                    const uri = grants[i].getElementsByTagName('URI')[0]?.textContent;
                    const permission = grants[i].getElementsByTagName('Permission')[0]?.textContent;
                    if (uri && uri.includes('AllUsers') && permission === 'READ') {
                        isPublic = true;
                        break;
                    }
                }
                document.getElementById('acl-status').textContent = isPublic ? 'Public Read' : 'Private';
                document.getElementById('acl-select').value = isPublic ? 'public-read' : 'private';
            } else {
                document.getElementById('acl-status').textContent = 'Private';
                document.getElementById('acl-select').value = 'private';
            }
        } catch (error) {
            document.getElementById('acl-status').textContent = 'Private';
            document.getElementById('acl-select').value = 'private';
        }

    } catch (error) {
        // Fallback for any unexpected errors
        document.getElementById('versioning-status').textContent = 'Error';
        document.getElementById('cors-status').textContent = 'Error';
        document.getElementById('acl-status').textContent = 'Error';
    }
}

async function toggleVersioning() {
    const bucketName = document.getElementById('settings-bucket-name').textContent;
    const currentStatus = document.getElementById('versioning-status').textContent;
    const newStatus = currentStatus === 'Enabled' ? 'Suspended' : 'Enabled';
    
    console.log(`Toggling versioning: ${currentStatus} -> ${newStatus}`);
    
    try {
        const versioningXml = `<?xml version="1.0" encoding="UTF-8"?>
<VersioningConfiguration>
    <Status>${newStatus}</Status>
</VersioningConfiguration>`;

        const url = `/spider/${bucketName}?versioning&ConnectionName=${connConfig}`;
        console.log(`Making PUT request to: ${url}`);
        console.log(`Request body: ${versioningXml}`);

        const response = await fetch(url, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/xml',
                'X-Connection-Name': connConfig
            },
            body: versioningXml
        });

        console.log(`Response status: ${response.status} ${response.statusText}`);

        if (response.ok) {
            console.log('Versioning toggle successful, reloading status...');
            setTimeout(() => {
                loadBucketSettings(bucketName);
            }, 1000);
            
            alert(`Versioning ${newStatus.toLowerCase()} successfully`);
        } else {
            const responseText = await response.text();
            console.error(`Error response: ${responseText}`);
            
            if (responseText.includes('<Error>')) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(responseText, 'text/xml');
                const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || responseText;
                throw new Error(`${errorCode}: ${errorMessage}`);
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        }
    } catch (error) {
        console.error('Toggle versioning error:', error);
        alert('Error toggling versioning: ' + error.message);
    }
}

async function enableCORS() {
    const bucketName = document.getElementById('settings-bucket-name').textContent;
    
    try {
        const corsXml = `<?xml version="1.0" encoding="UTF-8"?>
<CORSConfiguration>
    <CORSRule>
        <AllowedOrigin>*</AllowedOrigin>
        <AllowedMethod>GET</AllowedMethod>
        <AllowedMethod>PUT</AllowedMethod>
        <AllowedMethod>POST</AllowedMethod>
        <AllowedMethod>DELETE</AllowedMethod>
        <AllowedMethod>HEAD</AllowedMethod>
        <AllowedHeader>*</AllowedHeader>
        <ExposeHeader>ETag</ExposeHeader>
        <ExposeHeader>x-amz-server-side-encryption</ExposeHeader>
        <ExposeHeader>x-amz-request-id</ExposeHeader>
        <ExposeHeader>x-amz-id-2</ExposeHeader>
        <MaxAgeSeconds>3600</MaxAgeSeconds>
    </CORSRule>
</CORSConfiguration>`;

        const response = await fetch(`/spider/${bucketName}?cors&ConnectionName=${connConfig}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/xml'
            },
            body: corsXml
        });

        if (response.ok) {
            document.getElementById('cors-status').textContent = 'Configured';
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    } catch (error) {
        alert('Error enabling CORS: ' + error.message);
    }
}

async function deleteCORS() {
    const bucketName = document.getElementById('settings-bucket-name').textContent;
    
    try {
        const response = await fetch(`/spider/${bucketName}?cors&ConnectionName=${connConfig}`, {
            method: 'DELETE'
        });

        if (response.ok) {
            document.getElementById('cors-status').textContent = 'Not configured';
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    } catch (error) {
        alert('Error deleting CORS: ' + error.message);
    }
}

async function setACL() {
    const bucketName = document.getElementById('settings-bucket-name').textContent;
    const aclValue = document.getElementById('acl-select').value;
    
    try {
        const response = await fetch(`/spider/${bucketName}?acl&ConnectionName=${connConfig}`, {
            method: 'PUT',
            headers: {
                'x-amz-acl': aclValue,
                'X-Connection-Name': connConfig
            }
        });

        if (response.ok) {
            document.getElementById('acl-status').textContent = aclValue === 'public-read' ? 'Public Read' : 'Private';
        } else {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    } catch (error) {
        alert('Error setting ACL: ' + error.message);
    }
}

function generatePresignedURL(bucket, key) {
    document.getElementById('presigned-object-key').textContent = key;
    document.getElementById('presigned-url-result').style.display = 'none';
    document.getElementById('presigned-url-overlay').style.display = 'flex';
    
    window.currentPresignedContext = { bucket, key };
}

function hidePresignedURLOverlay() {
    document.getElementById('presigned-url-overlay').style.display = 'none';
    document.getElementById('presigned-url-result').style.display = 'none';
}

async function generatePresignedURLAction() {
    const { bucket, key } = window.currentPresignedContext;
    const hours = parseInt(document.getElementById('expiration-hours').value) || 1;
    const method = document.getElementById('presigned-method').value;
    const expiresSeconds = hours * 3600;

    try {
        const presignedURL = `/spider/${bucket}/${encodeURIComponent(key)}?ConnectionName=${connConfig}&expires=${Date.now() + (expiresSeconds * 1000)}`;
        
        document.getElementById('presigned-url-text').value = presignedURL;
        document.getElementById('presigned-url-result').style.display = 'block';
        
    } catch (error) {
        alert('Error generating presigned URL: ' + error.message);
    }
}

function copyPresignedURL() {
    const urlText = document.getElementById('presigned-url-text');
    urlText.select();
    urlText.setSelectionRange(0, 99999);
    navigator.clipboard.writeText(urlText.value).then(() => {
        alert('URL copied to clipboard!');
    }).catch(() => {
        alert('Failed to copy URL to clipboard');
    });
}

function showObjectVersions() {
    if (!currentBucket) {
        console.error('No current bucket selected');
        alert('Please select a bucket first');
        return;
    }
    
    console.log(`Opening object versions for bucket: ${currentBucket}`);
    document.getElementById('versions-bucket-name').textContent = currentBucket;
    document.getElementById('object-versions-overlay').style.display = 'flex';
    
    loadObjectVersionsWithActions(currentBucket);
}

function hideObjectVersionsOverlay() {
    document.getElementById('object-versions-overlay').style.display = 'none';
}

async function loadObjectVersionsWithActions(bucketName) {
    try {
        const url = `/spider/${bucketName}?versions&ConnectionName=${connConfig}`;
        
        const response = await fetch(url);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const xmlData = await response.text();
        
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
        
        const parseError = xmlDoc.getElementsByTagName('parsererror')[0];
        if (parseError) {
            throw new Error('Failed to parse XML response');
        }
        
        const listVersionsResult = xmlDoc.getElementsByTagName('ListVersionsResult')[0];
        if (!listVersionsResult) {
            throw new Error('Invalid XML response format - no ListVersionsResult');
        }
        
        const versions = xmlDoc.getElementsByTagName('Version');
        const deleteMarkers = xmlDoc.getElementsByTagName('DeleteMarker');
        
        const tbody = document.getElementById('object-versions-body');
        tbody.innerHTML = '';

        let hasVersions = false;

        for (let i = 0; i < versions.length; i++) {
            const version = versions[i];
            const key = version.getElementsByTagName('Key')[0]?.textContent || '';
            const versionId = version.getElementsByTagName('VersionId')[0]?.textContent || '';
            const size = parseInt(version.getElementsByTagName('Size')[0]?.textContent || '0');
            const lastModified = version.getElementsByTagName('LastModified')[0]?.textContent || '';
            const isLatest = version.getElementsByTagName('IsLatest')[0]?.textContent === 'true';

            hasVersions = true;
            
            const keyDisplay = size > 0 ? 
                `<span style="cursor:pointer; color: #0066cc; text-decoration: underline;" onclick="downloadObjectVersion('${bucketName}', '${key.replace(/'/g, "\\'")}', '${versionId}')">${key}</span>` : 
                key;
            
            tbody.innerHTML += `
                <tr>
                    <td>${keyDisplay}</td>
                    <td>${versionId}</td>
                    <td>${formatBytes(size)}</td>
                    <td>${formatTime(lastModified)}</td>
                    <td>${isLatest ? 'Yes' : 'No'}</td>
                    <td>
                        ${size > 0 ? `<button onclick="downloadObjectVersion('${bucketName}', '${key.replace(/'/g, "\\'")}', '${versionId}')" 
                                               style="background: #17a2b8; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">
                                          Download
                                      </button>` : ''}
                        <button onclick="deleteObjectVersion('${bucketName}', '${key.replace(/'/g, "\\'")}', '${versionId}')" 
                                style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">
                            Delete
                        </button>
                    </td>
                </tr>
            `;
        }

        for (let i = 0; i < deleteMarkers.length; i++) {
            const marker = deleteMarkers[i];
            const key = marker.getElementsByTagName('Key')[0]?.textContent || '';
            const versionId = marker.getElementsByTagName('VersionId')[0]?.textContent || '';
            const lastModified = marker.getElementsByTagName('LastModified')[0]?.textContent || '';
            const isLatest = marker.getElementsByTagName('IsLatest')[0]?.textContent === 'true';

            const versionIdElement = marker.getElementsByTagName('VersionId')[0];
            let actualVersionId = versionId;
            
            if (versionIdElement) {
                actualVersionId = versionIdElement.textContent || versionIdElement.innerHTML || '';
            }

            hasVersions = true;
            
            const displayVersionId = actualVersionId || 'null';
            
            tbody.innerHTML += `
                <tr style="background-color: #ffe6e6;">
                    <td>${key} (DELETE MARKER)</td>
                    <td>${displayVersionId}</td>
                    <td>-</td>
                    <td>${formatTime(lastModified)}</td>
                    <td>${isLatest ? 'Yes' : 'No'}</td>
                    <td>
                        <button onclick="deleteObjectVersion('${bucketName}', '${key.replace(/'/g, "\\'")}', '${actualVersionId}')" 
                                style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">
                            Delete
                        </button>
                    </td>
                </tr>
            `;
        }

        if (!hasVersions) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">No versions found</td></tr>';
        }

    } catch (error) {
        const tbody = document.getElementById('object-versions-body');
        tbody.innerHTML = 
            `<tr><td colspan="6" style="text-align: center; padding: 20px; color: red;">
                Error loading versions: ${error.message}
                <br><br>
                <button onclick="loadObjectVersionsWithActions('${bucketName}')" style="margin-top: 10px;">Retry</button>
            </td></tr>`;
        alert('Error loading object versions: ' + error.message);
    }
}

function searchKeyword() {
    const filter = document.getElementById('searchInput').value.trim().toUpperCase();
    highlightRows(document.getElementById('bucket-table'), filter);
    highlightRows(document.getElementById('object-table'), filter);
}

function highlightRows(table, filter) {
    if (!table) return;
    const trs = table.getElementsByTagName('tr');
    for (let i=1; i<trs.length; i++) {
        let found = false;
        for (let j=0; j<trs[i].cells.length; j++) {
            if ((trs[i].cells[j].textContent||'').toUpperCase().indexOf(filter) > -1) found = true;
        }
        trs[i].style.background = found && filter ? '#fffab6' : '';
    }
}

function clearSearchInput() {
    document.getElementById('searchInput').value = '';
    searchKeyword();
}

function toggleSelectAll(source, mode) {
    let checkboxes = [];
    if (mode === 'bucket') checkboxes = document.getElementsByName('bucket-checkbox');
    if (mode === 'object') checkboxes = document.getElementsByName('object-checkbox');
    for (const c of checkboxes) c.checked = source.checked;
}

function formatTime(iso) {
    if (!iso) return '';
    const d = new Date(iso);
    return `${d.getFullYear()}-${(d.getMonth()+1).toString().padStart(2,'0')}-${d.getDate().toString().padStart(2,'0')} ${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;
}

function formatBytes(bytes) {
    if (!bytes || isNaN(bytes)) return '';
    if (bytes < 1024) return bytes + ' B';
    let kb = bytes/1024;
    if (kb < 1024) return kb.toFixed(1)+' KB';
    let mb = kb/1024;
    if (mb < 1024) return mb.toFixed(1)+' MB';
    let gb = mb/1024;
    return gb.toFixed(1)+' GB';
}

document.addEventListener('DOMContentLoaded', () => {});
</script>
</body>
</html>